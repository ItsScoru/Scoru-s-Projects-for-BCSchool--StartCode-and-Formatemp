A– Rispondi alle seguenti domande argomentando la risposta:
1) Definisci la differenza tra oggetto, classe e istanza.
2) Cos’è il processo di astrazione?
3) Qual è lo scope di una variabile?
4) Cosa sono gli operatori logico booleani?
5) Definisci gli inizializzatori.
6) Cos’è il tipo di ritorno di un metodo e cosa implica?
7) Cosa sono i Wrapper?
8) Che differenza c’è tra le strutture di controllo selettive e quelle iterative?
9) Descrivi quali sono le figure professionali che si occupano dei progetti.
10) Definisci gli array e fai un esempio.
11) Quali sono i modificatori d’accesso?
12) Descrivi il modificatore static.
13) Descrivi l’utilizzo della parola chiave final.
14) Per cosa utilizziamo abstract?
15) Descrivere il processo dell’incapsulamento.
16) Cosa sono getters e setters e a cosa servono?
17) Cosa rappresenta l’ereditarietà in Java?
18) Quali sono le conseguenze dell’ereditarietà?
19) Cosa sono le interfacce?
20) Che differenza c’è tra classe astratta ed interfaccia?
21) Definisci l’overload.
22) Definisci l’override.
23) Spiega cos’è il polimorfismo.
24) Qual è la differenza tra polimorfismo per dati e polimorfismo per metodi?
25) Cos’è un’eccezione? Che differenza c’è tra checked e unchecked?
26) Quando utilizziamo il multi catch?
27) Cosa sono i generics
28) Qual è la sintassi dell’espressione lambda?
29) Definisci Framework Collections?
30) Spiega le differenze tra HashSet e TreeSet.

1) Un Oggetto in Java è un concetto, ovvero l'idea d'insieme che si ha di un'istanza in relazione
    alla classe a cui appartiene. Una Classe è un file .java che può contenere attributi,
    costruttori, metodi, inizializzatori o anche il main ed è l'insieme di caratteristiche e
    istruzioni che compongono un oggetto. Un'istanza invece un identificatore che fa riferimento
    alla classe per la quale viene creata e ci permette di accedere a tutte le funzionalità
    dell'Oggetto, come i metodi d'istanza o gli attributi.
2) A volte in Java si ha la necessità di creare delle classi generiche per migliorare la
    stesura di codice. In certi casi, queste classi si rivelano essere fin troppo generiche,
    tanto che un'implementazione di metodi potrebbe risultare corretta per una determinata
    classe ma incorretta per un'altra. Ecco quindi che si fa uso dell'astrazione, dichiarando
    una classe astratta con la parola chiave "abstract", nella stessa si possono esplicitare
    quali metodi le sottoclassi dovrebbero implementare senza però dotarli di un blocco di
    quel blocco di codice poco specifico e quindi non adatto.
3) Lo scope di una variabile è il nome che diamo alla stessa. Ovvero un identificatore che
    permette al nostro codice di accedere a quel determinato spazio della memoria nel quale
    il dato della variabile è contenuto.
4) Sono AND, OR, XOR e NOT, e permettono di eseguire delle verifiche che restituiscono
    un tipo di dato boolean (ovvero vero cioè 1 o falso cioè 0) (&&, ||, ^, !)
5) Gli inizializzatori possono essere sia statici che d'istanza, e sono dei blocchi di
    codice che vengono eseguiti rispettivamente la prima volta che una classe viene
    istanziata nel codice ed ogni qual volta un'istanza di una classe viene creata.
6) A volte si ha la necessità di svolgere delle istruzioni per avere un tipo di dato.
    Se queste istruzioni dovrebbero essere ripetute spesso nel codice, per semplificare,
    inrobustire e velocizzare il processo di stesura si possono inserire all'interno di un
    metodo a loro dedicato. Il tipo di ritorno indica cosa restituisce quel metodo una volta
    che ha completato le istruioni, che sia un int, una Stringa o qualsiasi altro dato (un
    esempio lampante sono i metodi get()).
7) Sono delle classi al cui interno sono contenuti i tipi primitivi.
8) Una struttura di controllo selettiva permette di controllare il flusso del codice in
    base a determinate condizioni. Una iterativa invece permette di eseguire un blocco di
    codice finchè una certa condizione è true.
9) I Progect Manager sono coloro che si occupano di coordinare il personale e gestire la
    direzione di sviluppo dei prgetti. I Software Developer sono coloro che si occupano di
    scrivere e testare il codice. Gli IT engineer sono coloro che verificano l'infrastruttura
    e sono responsabili di installare e aggiornare il software in tutte le macchine in cui
    è installato. I Data analysts sono coloro che si occupano di raccogliere, analizzare,
    gestire ed utilizzare tutti i dati necessari allo sviluppo di un progetto. I Security
    manager sono coloro che si occupano della sicurezza di un progetto.
10) Gli array sono un insieme di dati di grandezza finita al cui interno si può inserire
    qualsiasi tipo di dato o Oggetto. (char[] arrayCaratteri = new char[3];)
11) private, protected, package, public o anche non esplicitato.
12) static è una parola chiave che può essere utilizzata da metodi, attributi e
    inizializzatori per esplicitare che non appartengono alla singola istanza ma sono
    racchiuse solo nella classe. Un metodo statico non ha bisogno di un'istanza per essere
    chiamato. Se la classe che lo contiene è importata si può addirittura evitare di scrivere
    Classe.mioMetodoStatico();. Un inizializzatore statico verrà eseguito una sola volta a
    prescindere dal numero di istanze create di quella classe. Gli attributi statici sono
    dei dati condivisi da tutte le istanze di quella classe (Come per esempio l'esercizio della
    lampadina e della corrente)
13) final viene utilizzata da classi, metodi e attributi. Una classe final non ne permette
    l'estenzione (e quindi la creaizone di sottoclassi). Un metodo final è un metodo che non
    può più essere sovrascritto con un @Override. Un attributo final viene non è più una
    variaile ma diventa una costante e può anche essere usato nelle enumerazioni.
14) abstract è una parola chiave utiizzata per indicare una classe o un metodo astratti.
15) L'incapsulamento è l'esplicitazione della visibiltà delle varie caratteristiche di
    una classe. Utilizzando i modificatori d'accesso si può rendere un determinato elemento
    di una classe, o anche la classe stessa (per esempio per più classi scritte in un unico
    file) inaccessibile ammenochè non si sia in una sottoclasse. O ancora renderlo visibile a
    chiunque provi ad accedervi. O anche "privato" per la sola classe che lo dichiara ecc.
16) I metodi Getters e Setters sono dei metodi con nomenclatura convenzionata che sono utilizzati
    per manipolare gli attributi. I setter (solitamente utilizzati nei costruttori di 
    un'istanza) (solitamente dichiarati con tipo di ritorno void) permettono di inizzializzare
    un'attributo, solitamente con lo stesso valore di un parametro utilizzato dal metodo
    getAttributo(Parametro par);. I Getter al contrario restituiscono (esplicitando un tipo
    di ritorno) solitamente un'attributo.
17) L'ereditarietà è un concetto chiave in java. Senza l'ereditarietà, due classi simili come
    Ciclista e Impiegato, che hanno dichiarati al loro interno attributi o metodi simili come
    String nome, metodoPresentarsi(), ecc. dovranno aver riscritto al loro interno tutta una
    serie di codici necessari al loro funzionamento. Con l'ereditarietà invece, per quanto classi
    diverse, si possono entrambe rendere sottoclassi di Persona. Quest'ultima avrà quindi String
    nome ecc. potendo così velocizzare e semplificare la stesura del codice.
18) L'ereditarietà permette alle sottoclassi di utilizzare i metodi o gli attributi non privati
    della loro superclasse.
19) Le interfacce sono simili alle classi. Normalmente dovrebbero possedere soltanto dei metodi
    (quando ne posseggono solo uno sono dette interfacce funzionali) e permettono la condivisione
    di certi metodi utili a più classi senza la necessità di raggruppare quelle classi sotto
    un'unica superclasse (perchè magari completamente scollegate.) Un interfaccia molto
    utilizzata è Runnable, che permette di implementare il metodo run(), il quale viene
    utilizzato per la creazione di Threads. Se Runnable fosse stata una superclasse, qualsiasi
    sua sottoclasse avrebbe potuto ereditare il metodo, anche classi dove non serve, rendendo
    inoltre impossibile poter rendere quelle sottoclassi sottoclassi di altre superclassi.
    Invece in Java si possono implementare molteplici interfacce.
20) Una classe astratta obbliga la sottoclasse ad implementarne i metodi se quella sottoclasse
    non necessita di essre astratta. Le interfacce invece non obbligano questa scelta. Se,
    quindi, in un'ipotetica interfaccia contenente 100 metodi diversi, nella classe ne
    verrà utilizzato soltanto uno, non sorgeranno problemi, al contrario, se una classe
    astratta implementa 3 metodi, il compilatore segnalerà l'assenza dei metodi non
    implementati.
21) L'@Overload è la possibilità di poter definire più metodi, che condividono una funzionalità
    simile, con lo stesso identificatore, purchè i parametri d'ingresso li differenzino. Java
    infatti riesce a dedurre quale metodo utilizzare, anche se tutti con lo stesso nome, proprio
    grazie ai parametri (un esempio sono i costruttori).
22) L'@Override è la possibilità di una sottoclasse di poter riscrivere un metodo già
    implementato dalla sua superclasse, modificandone il funzionamento per adattarlo alle proprie
    necessità, avendo anche la possibilità di richiamare lo stesso metodo della superclasse, di
    cui si sta facendo l'override con la parola chiave "super".
23) Il polimorfismo è la possibilità delle sottoclassi di una classe di implementare un metodo
    della loro superclasse in modi diversi senza che si creino ambiguità.
24) Il polimorfirmo dei dati permette ad un identificatore di una superclasse di puntare ad
    un'istanza di una sua sottoclasse (Persona caio = new Ciclista();), il polimorfismo dei
    metodi invece permette ad una sottoclasse di eseguire l'override di un metodo della sua
    superclasse.
25) Un'eccezione un'oggetto della classe Exception o delle sue sottoclassi che interrompe
    lo svolgimento del programma e resituisce una descrizione del problema nella console.
    Le eccezioni unchecked sono delle eccezioni che si verificano al Runtime (come 
    RuntimeException e le sue sottoclassi o Error) e non necessitano di essere racchiuse
    in un blocco try/catch. Al contrario, le checked danno un errore di compilazione se non
    inserite all'interno di quest'ultimo.
26) Un blocco try/catch con multipli catch è usato nel caso in cui sappiamo che una determinata
    istruzione possa lanciare più eccezioni e si vuole gestire quelle ececzioni in modi
    diversi.
27) I tipi generics sono degli identificatori che vengono usati in classi e metodi. La
    necessità di utilizzare i generics si ha qualora si debba creare una classe senza
    funzionalità specifiche, che quindi possa accogliere più tipi di dato (è molto importante
    utilizzare solo oggetti o wrapper). Gli array, le liste, le mappe ecc. sono tutte
    classi che utilizzano i generics perchè tutto giò che fanno è contenere o restituire
    quegli stessi dati che sono contenuti al loro interno, senza modificarne i valori.
28) Una lambda si indica con un identificatore, seguito dall'operatore freccia "->", seguito
    a sua volta da un'istruzione o un blocco di codice.
29) Il framework Collection è un insieme di classi presente nella JSL che permette il
    raggruppamento di vari tipi di dato in vari modi. List, Map e Set sono le classi madri
    che racchiudono anche i concetti di Collection, anche se non esistono solo loro (si può
    parlare di Arraylist, HashMap, TreeMap, HashSet, TreeSet, Queue, Deque ed altri ancora).
30) Un HashSet è una collezione di dati, al cui interno vengono registrati in modo "naturale",
    ovvero per ordine di inserimento. Un TreeSet è una collezione di dati che
    registra i dati comparandoli gli uni agli altri tramite un Comparator e li registra, come
    dice il nome, come se fossero biforcazioni di rami, posizionando il comparator ora a destra
    ora a sinistra del dato, e infine inserendolo nella posizione corretta.