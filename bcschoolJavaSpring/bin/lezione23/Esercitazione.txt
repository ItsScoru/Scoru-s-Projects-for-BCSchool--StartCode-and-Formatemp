A – Rispondi alle seguenti domande argomentando la risposta:
1) Descrivi l’architettura monolitica.
2) Che cos’è un microservizio?
3) Definisci le differenze tra architettura monolitica e microservizi.
4) Cosa si intente per xml? E per Json?
5) Cosa si intente per scalabilità?
6) Che ruolo ha il team nella realizzazione di un microservizio?
7) Cosa si intende per inconsistenza dei dati?
8) Che differenza c’è tra la comunicazione sincrona e quella asincrona?
9) Definisci il Circuit Breaker.
10) Cosa si intende per continuos deployment?
11) Definisce un ORM.
12) Come può essere classificato un sistema ORM? Argomenta.
13) Cos’è Hibernate?
14) Cosa si intende per persistenza dei dati?
15) Quali sono le caratteristiche degli stati di persistenza?
16) Cos’è una session? E una Session Factory?
17) Cosa si intende per jdbc?
18) Che cos’è la serializzazione? E la deserializzazione?
19) Cos’è Unified Modeling Language?
20) Definisci il diagramma delle classi.
21) Spiega le differenze tra associazioni, aggregazioni e composizione.
22) Si elenchino le caratteristiche di un Java Bean e quelle di un Entity Bean.
23) Quali sono le differenze tra jdbs e hibernate?
24) Descrivere il ciclo di vita di un’entità.
25) Quale libreria viene implementata ed estesa da Hibernate?
26) Descrivere Statement, Preparate Statement e Result Set.
27) A cosa serve il file hibernate.cfg.xml?
28) A cosa serve il file pom.xml?
29) Quali sono le opzioni possibili per hibernate.hbm2ddl.auto?
30) Come si possono configurare le relazioni tra Entity in Hibernate?

1) L'architettura monolitiga è un modo obsoleto di costrutire un servizio. Le
    sue varie componenti dipendono tutte le une dalle altre, ciò la rende
    un'architettura lenta e di difficile manutenzione, oltre che poco adattabile.
2) Un microservizio è un componente dell'architettura a microservizi, ovvero una
    piccola applicazione a se stante ed autonoma che collabora con altri
    microservizi per fornire, appunto, un servizio più grande e complesso, più 
    veloce, versatile e facile da mantenere aggiornato e funzionante.
3) L'architettura monolitica è obsoleta, lenta (perchè si basa su un unico
    database), difficile da aggiornare e manutenere. Al contrario una
    architettura a microservizi suddivide le informazioni e il carico di lavoro
    su vari programmi indipendenti, i quali (se raggruppati bene secondo le
    informazioni a cui devono accedere) non si accalcano su un unico database
    riducendo i tempi di risposta. Essendo inoltre autonomi o con pochissimi
    legami ad altri microservizi, si riduce notevolmente la mole di lavoro
    richiesta per mantenere aggiornata una sua funzione e la risoluzione di
    eventuali bug.
4) XML sta per Extensible Markup Language, ovvero un file di descrizione delle
    risorse che si basa sui tag. JSON sta per JavaScript Object Notation, un altro
    tipo di file utilizzato per la descrizione delle risorse che su basa sul testo.
5) La caratteristica di un servizio di potersi adattare alle richieste del cliente,
    che siano l'espansione sia verticale che orizzontale oppure l'adattamento a
    diverse macchine o ancora la modifica di funzionalità.
6) Il team è responsabile dello sviluppo, del testing, della manutenzione e dello
    sviluppo durante il ciclo di vita dell'applicazione.
7) Il salvataggio di dati sui database con tipi o valori sbagliati che possa far 
    sorgere degli errori o delle eccezioni durante l'utilizzo del servizio.
8) Nella comunicazione sincrona i microservizi interagiscono tra di loro e si
    scambiano informazioni tramite i databases in tempo reale, in quella asincrona
    questo non avviene perchè, anche se le informazioni vengono scambiate, i
    microservizi non aspettano per una conferma di ricezione e continuano l'esecuzione.
9) 
10) L'attività da parte di un team di mantenere aggiornato e funzionante un
    microservizio.
11) Object Relation Mapping, ovvero uno standard di rappresentazione grafica dei
    database che si basa su gli elementi del database sottoforma di oggetti e le
    relazioni che essi presentano.
12) Un sistema ORM può essere caratterizzato da relazioni pure, ovvero uno schema
    molto simile ad SQL; caratterizzato da un "Light Object Mapping" dove le
    entità sono mappate manualmente e la parte di SQL o JDBC è nascosta;
    caratterizzato da un "Medium Object Mapping" che si basa sui modelli ad
    oggetti, ha una cache e l'SQL è generato al Runtime (quindi non c'è bisogno
    di scriverlo) oppure può essere caratterizzato da un "Full Object Mapping", il
    quale supporta l'ereditarietà delle classi di java ed ha numerose ottimizzazioni.
13) Hibernate è un ORM che permette lo sviluppo di programmi utilizzando Maven, java
    è un database come Apache di Xampp. Si basa sul HQL ed è caratterizzato da un Core,
    dal quale si installano le dependencies, con le quali si possono utilizzare le 
    Annotations per indicare all Entity Manager come vogliamo manipolare il database.
14) La capacità di un dato di continuare ad esistere dopo l'esecuzione del codice,
    ovvero la possibilità dei dati di essere salvati in un database mediante il
    codice stesso.
15) 
16) Una session è banalmente la sessione tramite la quale possiamo utilizzare la
    cache, nella quale possiamo creare della transazioni per manipolare i database.
    La SessionFactory è la classe che ci permette di creare la session e utilizzarne
    i metodi.
17) JDBC sta per Java DataBase Connectivity ed è una raccolta di classi e metodi
    come Connection, Statement e ResultSet che ci permettono di manipolare i dati
    all'interno dei database a cui ci connettiamo.
18) Sono le due azioni che vengono effettuate durante la comunicazione di dati. La
    Serializzazione li compone in codice binario per essere trasferito più facilmente
    nel database e la deserializzazione permette di fare l'opposto per poter leggere
    i dati nei database.
19) 
20) Il diagramma delle classi è uno standard di rappresentazione grafica tramite il
    quale vengono rappresentate le classi di un progetto e le loro relazioni (come
    l'ereditarietà) attraverso specifici simboli. Una classe è una tabella che racchiude
    attributi e metodi, indicati come privati tramite il "-" e pubblici tramite il "+".
    In olter si può indicare l'ereditarietà tra le classi con una freccia che va dalla
    sottoclasse alla supercalsse, e anche gli insiemi che le classi hanno tra di loro
    come con le frecce che finiscono con un rombo o con un rombo riempito.
21) Le associazioni di classi si hanno quando una classe utilizza un'altra distinta 
    classe al suo interno. Un aggregazione è la relazione tra una classe e la possibilità
    di avere un insieme formato da altre classi. Una composizione è invece la caratteristica
    di una classe di avere un legame molto forte con un'altra classe perchè la prima è,
    appunto, composta dalla seconda.
22) Un Java bean è una classe contenitore che viene utilizzata nella serializzazione e 
    deserializzazione. Un entity bean è una specializzazione di un Java Bean che viene
    utilizzato per interagire con i dati di un database.
23) Hibernate utilizza HQL che è capace di interagire con gli ORM e con gli oggetti,
    JDBC invece crea una semplice connessione con il database ed esegue delle query
    in SQL che noi dobbiamo scrivere esplicitamente.
24) Un entità i cui valori non sono ancora salvati sul database si dice "Transient";
    non appena hibernate permette la sincronizzazione dei dati con il database
    l'entità diventa "Managed". Una volta in cui i dati di questa entità non vengono
    più sincronizzati con il database diventa "Detached" per poi essere eliminata
    divenendo quindi "Removed".
25) Java Persistence API, la JPA.
26) Statement è una classe di JDBC che permette di scrivere una query SQL in modo grezzo,
    quasi come si farebbe per le normali query SQL ma con la possibilità, essendo una
    Stringa, di poter aver inseriti valori passati al metodo che esegue la query o 
    dati più nel generale. PreparedStatement è un'altra classe di JDBC che permette la
    creazione di query SQL con la presenza del carattere "?", ovvero un carattere specializzazione
    che viene successivamente sovrascritto con i dati particolari che vogliamo utilizzare
    tramite il metodo getInt(index,dato); e simili presenti in PreparedStatement.
    ResultSet è una classe che permette di estrapolare, utilizzazre e manipolare i
    risultati delle query di interrogazione (come per esempio un ciclo con ResultSet.next()
    per stampare ogni elemento del set.)
27) Hibernate.cfg.xml è il file su cui si basa HibernateUtil per effettuare la connessione
    al database specificato. In questo file sono specificati gli username e password da
    utilizzare, la connessione, quale database, che entità sono presenti nel database e
    molto altro.
28) Pom.xml è un file creato da Maven che permette di scaricare, installare ed utilizzare
    le dependencies di Hibernate Core.
29) Create, Create-Drop, Update e Validate.
30) @OneToOne (relazione uno a uno), @OneToMany e @ManyToOne (relazione uno a molti),
    @ManyToMany (relazione molti a molti).


--------------------------------------------------------------------------------

B – Si crei un progetto jdbc che gestisca il database di studenti.
    Ogni Studente che dovrà avere i seguenti attributi: matricola, nome, cognome, età, data di nascita,
    nome del corso e esami sostenuti.
    All’interno di una classe main implementare i metodi per:
    • Aggiungere uno studente
    • Stampare uno studente
    • Stampare tutti gli studenti
    • Cancellare uno studente
    • Cancellare tutti gli studenti
    • Aggiornare uno studente
    • Aggiornare uno studente in base alla matricola


--------------------------------------------------------------------------------

C – Definire l’entità RichiestaFerie con le seguenti proprietà:
• id
• dataCreazione
• dataModifica
• emailAziedale
• giornoInizio
• giornoFine
• motivazione
• stato
• motivazioneRifiuto
Implementare la persistenza dell’entity tramite l’ORM Hibernate e l’implementazione del design pattern
DAO.
NB: creare le istanze e salvarle nel DB.

--------------------------------------------------------------------------------

D – Creare un progetto Java che usi Maven per gestire le dipendenze e che usi Hibernate per gestire la
    connessione con il database.
    Il database dovrà contenere tre tabelle Studente, Matricola e Corso.
    Studente: id come chiave primaria, nome e cognome.
    Matricola: id come chiave primaria, e matricola.
    Corso: id come chiave primaria, descrizione e denominazione.
    Inserire per ogni tabella 5 righe ed individuare le relazioni tra le tabelle
    Il progetto avrà:
    • Le classi o i file di configurazione
    • Tre entityBean
    • Una interfacciaDao con i metodi di crud generici
    • Tre classi Dao che implementano interfacciaDao
    • Una classe di test con un metodo main